{"version":3,"file":"perfect-immutable.mjs","sources":["../../src/stringToPath.js","../../src/splice.js","../../src/set.js","../../src/push.js","../../src/pop.js","../../src/shift.js","../../src/unshift.js","../../src/sort.js","../../src/reverse.js","../../src/delete.js","../../src/filter.js","../../src/fp/index.js"],"sourcesContent":["// see `_stringToPath.js` file in lodash repository\nconst pathPartReg = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst backslashReg = /\\\\(\\\\)?/g;\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(pathPartReg, function(match, number, quote, string) {\n    if (quote) {\n      result.push(string.replace(backslashReg, '$1'));\n    } else {\n      result.push(number ? parseInt(number) : match);\n    }\n  });\n  return result;\n};\n\nexport default stringToPath;\n","/**\n * Works like array.prototype.splice but returns new array instead of mutating it\n * @param {array} arr source array\n * @param {number} start zero-based index at which to start changing the array\n * @param {number} deleteCount an integer indicating the number of old array elements to remove\n * @param {array} items the elements to add to the array, beginning at the `start` index\n * @return {array} new array\n */\nconst immutableSplice = (arr, start, deleteCount, ...items) => [\n  ...arr.slice(0, start),\n  ...items,\n  ...arr.slice(start + deleteCount),\n];\n\nexport default immutableSplice;\n","import { tail, isPlainObject, isEmpty, has, reduce, isNumber, isString, isArray, isFunction } from 'lodash';\nimport stringToPath from './stringToPath';\nimport splice from './splice';\n\n/**\n * Immutably set not-nested value in target\n * @param {array|object} target to set the value in\n * @param {string|number} field field name or index to set the value in\n * @param {any|function} value value to set the in target or transformFunction\n * @param {boolean} setFunction if true, transformFunction will not be used as such but just saved in the path\n * @return {array|object} new array or object with altered value\n */\nconst setValue = (target, field, value, setFunction = false) => {\n  if (isArray(target)) {\n    if (!isNumber(field)) {\n      throw new Error(`Index in array must be a number but it is ${typeof field} and has value ${field}`);\n    }\n    const newValue = isFunction(value) && !setFunction ? value(target[field]) : value;\n    return splice(target, field, 1, newValue);\n  }\n  const newValue = isFunction(value) && !setFunction ? value(target[field]) : value;\n  return {\n    ...target,\n    [field]: newValue,\n  };\n};\n\n/**\n * Works like lodash _.set() but does not mutate target, works with arrays\n * @param {object|array} target source object or array\n * @param {string|object} path or index in object to set value in or object with paths/indexes as keys and values as values (if path is an object it ignores 'value')\n * @param {any|function} value to set in given path/index or transform function that accepts current value and returns new one\n * @param {boolean} setFunction if true and value provided is a function it will be treated as simple value and saved to the target (instead of used as transform)\n * @return {object|array} new object or array with value(s) changed\n */\nconst immutableSet = (target, path, value = null, setFunction = false) => {\n  if (!isArray(target) && !isPlainObject(target)) {\n    throw new Error(`First argument provided to immutableSet function must be a plain object or array but it's type is ${typeof target}`);\n  }\n  if (!isArray(path) && !isPlainObject(path) && !isString(path)) {\n    throw new Error(`Path passed to immutableSet function must be a string, array of strings and numbers or plain object but it's type is ${typeof path}`);\n  }\n\n  if (!path || (isArray(path) && !path.length)) {\n    return value;\n  }\n  if (isPlainObject(path)) {\n    if (isEmpty(path)) {\n      return target;\n    }\n    return reduce(path, (accu, value, path) => immutableSet(accu, path, value, setFunction), target);\n  }\n\n  let pathSplit = path;\n  if (!isArray(path)) {\n    pathSplit = stringToPath(path);\n  }\n  if (pathSplit.length === 1) {\n    return setValue(target, pathSplit[0], value, setFunction);\n  }\n  let childTarget = {};\n  if (has(target, pathSplit[0])) {\n    childTarget = target[pathSplit[0]];\n    if (!isPlainObject(childTarget) && !isArray(childTarget)) {\n      throw new Error(`Part of 'path' provided is defined in 'object' and is neither plain JS object nor array but ${typeof childTarget}. It's most likely an error. Check the path and object provided to immutableSet function`);\n    }\n  }\n  return setValue(target, pathSplit[0], immutableSet(childTarget, tail(pathSplit), value, setFunction));\n};\n\nexport default immutableSet;\n","/**\n * Works like array.protype.pop but returns new array instead of mutating existing one\n * @param {array} arr source array\n * @param {array} newEntries entries to add to the array\n * @return {array} new array with newEntries added\n */\nconst immutablePush = (arr, ...newEntries) => newEntries.reduce((result, newEntry) => [...result, newEntry], arr);\n\nexport default immutablePush;\n","/**\n * Works like array.protype.pop but returns new array instead of mutating existing one\n * @param {array} arr source array\n * @return {array} new array with last element removed\n */\nconst immutablePop = arr => arr.slice(0, -1);\n\nexport default immutablePop;\n","/**\n * Returns new array with first element removed\n * @param {array} arr source array\n * @return {array} new array with first element removed\n */\nconst immutableShift = arr => arr.slice(1);\n\nexport default immutableShift;\n","/**\n * Returns new array with new element(a) added at the beginning\n * @param {array} arr source array\n * @param {array} newEntries entries to be added at the beginning of the array (will appear in the same order as they were provided to the function)\n * @return {array} new array with newEntries added at the beginning\n */\nconst immutableUnshift = (arr, ...newEntries) =>\n  newEntries.reverse().reduce((result, newEntry) => [newEntry, ...result], arr);\n\nexport default immutableUnshift;\n","/**\n * Returns new, sorted array without mutating the source\n * @param {array} arr source array\n * @param {function} compareFunction function to compare values\n * @return {array} new, sorted array\n */\nconst immutableSort = (arr, compareFunction) => [...arr].sort(compareFunction);\n\nexport default immutableSort;\n","/**\n * Returns new, reversed array without mutating the source\n * @param {array} arr source array\n * @return {array} new, reversed array\n */\nconst immutableReverse = arr => [...arr].reverse();\n\nexport default immutableReverse;\n","/**\n * Creates new array with one element removed\n * @param {array} arr source array\n * @param {number} index of element we want to be removed\n * @return {array} new array with one element removed\n */\nconst immutableDelete = (arr, index) => arr.slice(0, index).concat(arr.slice(index + 1));\n\nexport default immutableDelete;\n","import { filter } from 'lodash';\n\n/**\n * Returns new, array only with elements predicate returns truthy for\n * @param {array} arr source array\n * @param {function} predicate function invoked per iteration\n * @return {array} new, filtered array\n */\nconst immutableFilter = (arr, predicate) => filter(arr, predicate);\n\nexport default immutableFilter;\n","import { curryRight } from 'lodash';\n\nimport immuSet from '../set';\nimport immuSplice from '../splice';\nimport immuPush from '../push';\nimport immuPop from '../pop';\nimport immuShift from '../shift';\nimport immuUnshift from '../unshift';\nimport immuSort from '../sort';\nimport immuReverse from '../reverse';\nimport immuDelete from '../delete';\nimport immuFilter from '../filter';\n\nexport const set = (path, value, setFunction) => target => immuSet(target, path, value, setFunction);\nexport const splice = (start, deleteCount, ...items) => arr => immuSplice(arr, start, deleteCount, ...items);\nexport const push = (...newEntries) => arr => immuPush(arr, ...newEntries);\nexport const pop = curryRight(immuPop);\nexport const shift = curryRight(immuShift);\nexport const unshift = (...newEntries) => arr => immuUnshift(arr, ...newEntries);\nexport const sort = curryRight(immuSort);\nexport const reverse = curryRight(immuReverse);\nexport const immutableDelete = curryRight(immuDelete);\nexport const filter = curryRight(immuFilter);\nexport const placeholder = curryRight.placeholder;\n\nexport default {\n  set,\n  splice,\n  push,\n  pop,\n  shift,\n  unshift,\n  sort,\n  reverse,\n  immutableDelete,\n  filter,\n  placeholder,\n};\n\n\n"],"names":["pathPartReg","backslashReg","stringToPath","result","replace","match","number","quote","string","push","parseInt","immutableSplice","arr","start","deleteCount","items","slice","setValue","target","field","value","setFunction","isArray","isNumber","Error","newValue","isFunction","splice","immutableSet","path","isPlainObject","isString","length","isEmpty","reduce","accu","pathSplit","childTarget","has","tail","immutablePush","newEntries","newEntry","immutablePop","immutableShift","immutableUnshift","reverse","immutableSort","compareFunction","sort","immutableReverse","immutableDelete","index","concat","immutableFilter","predicate","filter","set","immuSet","immuSplice","immuPush","pop","curryRight","immuPop","shift","immuShift","unshift","immuUnshift","immuSort","immuReverse","immuDelete","immuFilter","placeholder"],"mappings":"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"}