{"version":3,"file":"perfect-immutable.mjs","sources":["../src/stringToPath.js","../src/splice.js","../src/set.js","../src/push.js","../src/pop.js","../src/shift.js","../src/unshift.js","../src/sort.js","../src/reverse.js","../src/delete.js","../src/index.js"],"sourcesContent":["// see `_stringToPath.js` file in lodash repository\nconst pathPartReg = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst backslashReg = /\\\\(\\\\)?/g;\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(pathPartReg, function(match, number, quote, string) {\n    if (quote) {\n      result.push(string.replace(backslashReg, '$1'));\n    } else {\n      result.push(number ? parseInt(number) : match);\n    }\n  });\n  return result;\n};\n\nexport default stringToPath;\n","/**\n * Works like array.prototype.splice but returns new array instead of mutating it\n * @param {array} arr source array\n * @param {number} start zero-based index at which to start changing the array\n * @param {number} deleteCount an integer indicating the number of old array elements to remove\n * @param {array} items the elements to add to the array, beginning at the `start` index\n * @return {array} new array\n */\nconst immutableSplice = (arr, start, deleteCount, ...items) => [\n  ...arr.slice(0, start),\n  ...items,\n  ...arr.slice(start + deleteCount),\n];\n\nexport default immutableSplice;\n","import { tail, isPlainObject, isEmpty, has, reduce, isNumber, isString, isArray } from 'lodash';\nimport stringToPath from './stringToPath';\nimport splice from './splice';\n\n/**\n * Immutably set not-nested value in target\n * @param {array|object} target to set the value in\n * @param {string|number} field field name or index to set the value in\n * @param {any} value value to set the in target\n * @return {array|object} new array or object with altered value\n */\nconst setValue = (target, field, value) => {\n  if (isArray(target)) {\n    if (!isNumber(field)) {\n      throw new Error(`Index in array must be a number but it is ${typeof field} and has value ${field}`);\n    }\n    return splice(target, field, 1, value);\n  }\n  return {\n    ...target,\n    [field]: value,\n  };\n};\n\n/**\n * Works like lodash _.set() but does not mutate target, works with arrays\n * @param {object|array} target source object or array\n * @param {string|object} path or index in object to set value in or object with paths/indexes as keys and values as values (if path is an object it ignores 'value')\n * @param {any} value to set in given path/index\n * @return {object|array} new object or array with value(s) changed\n */\nconst immutableSet = (target, path, value = null) => {\n  if (!isArray(target) && !isPlainObject(target)) {\n    throw new Error(`First argument provided to immutableSet function must be a plain object or array but it's type is ${typeof target}`);\n  }\n  if (!isArray(path) && !isPlainObject(path) && !isString(path)) {\n    throw new Error(`Path passed to immutableSet function must be a string, array of strings and numbers or plain object but it's type is ${typeof path}`);\n  }\n\n  if (!path || (isArray(path) && !path.length)) {\n    return value;\n  }\n  if (isPlainObject(path)) {\n    if (isEmpty(path)) {\n      return target;\n    }\n    return reduce(path, (accu, value, path) => immutableSet(accu, path, value), target);\n  }\n\n  let pathSplit = path;\n  if (!isArray(path)) {\n    pathSplit = stringToPath(path);\n  }\n  if (pathSplit.length === 1) {\n    return setValue(target, pathSplit[0], value);\n  }\n  let childTarget = {};\n  if (has(target, pathSplit[0])) {\n    childTarget = target[pathSplit[0]];\n    if (!isPlainObject(childTarget) && !isArray(childTarget)) {\n      throw new Error(`Part of 'path' provided is defined in 'object' and is neither plain JS object nor array but ${typeof childTarget}. It's most likely an error. Check the path and object provided to immutableSet function`);\n    }\n  }\n  return setValue(target, pathSplit[0], immutableSet(childTarget, tail(pathSplit), value));\n};\n\nexport default immutableSet;\n","/**\n * Works like array.protype.pop but returns new array instead of mutating existing one\n * @param {array} arr source array\n * @param {array} newEntries entries to add to the array\n * @return {array} new array with newEntries added\n */\nconst immutablePush = (arr, ...newEntries) => newEntries.reduce((result, newEntry) => [...result, newEntry], arr);\n\nexport default immutablePush;\n","/**\n * Works like array.protype.pop but returns new array instead of mutating existing one\n * @param {array} arr source array\n * @return {array} new array with last element removed\n */\nconst immutablePop = arr => arr.slice(0, -1);\n\nexport default immutablePop;\n","/**\n * Returns new array with first element removed\n * @param {array} arr source array\n * @return {array} new array with first element removed\n */\nconst immutableShift = arr => arr.slice(1);\n\nexport default immutableShift;\n","/**\n * Returns new array with new element(a) added at the beginning\n * @param {array} arr source array\n * @param {array} newEntries entries to be added at the beginning of the array (will appear in the same order as they were provided to the function)\n * @return {array} new array with newEntries added at the beginning\n */\nconst immutableUnshift = (arr, ...newEntries) =>\n  newEntries.reverse().reduce((result, newEntry) => [newEntry, ...result], arr);\n\nexport default immutableUnshift;\n","/**\n * Returns new, sorted array without mutating the source\n * @param {array} arr source array\n * @param {function} compareFunction function to compare values\n * @return {array} new, sorted array\n */\nconst immutableSort = (arr, compareFunction) => [...arr].sort(compareFunction);\n\nexport default immutableSort;\n","/**\n * Returns new, reversed array without mutating the source\n * @param {array} arr source array\n * @return {array} new, reversed array\n */\nconst immutableReverse = arr => [...arr].reverse();\n\nexport default immutableReverse;\n","/**\n * Creates new array with one element removed\n * @param {array} arr source array\n * @param {number} index of element we want to be removed\n * @return {array} new array with one element removed\n */\nconst immutableDelete = (arr, index) => arr.slice(0, index).concat(arr.slice(index + 1));\n\nexport default immutableDelete;\n","import immuSet from './set';\nimport immuSplice from './splice';\nimport immuPush from './push';\nimport immuPop from './pop';\nimport immuShift from './shift';\nimport immuUnshift from './unshift';\nimport immuSort from './sort';\nimport immuReverse from './reverse';\nimport immuDelete from './delete';\n\nexport const set = immuSet;\nexport const splice = immuSplice;\nexport const push = immuPush;\nexport const pop = immuPop;\nexport const shift = immuShift;\nexport const unshift = immuUnshift;\nexport const sort = immuSort;\nexport const reverse = immuReverse;\nexport const immutableDelete = immuDelete;\n\nexport default {\n  set,\n  splice,\n  push,\n  pop,\n  shift,\n  unshift,\n  sort,\n  reverse,\n  immutableDelete,\n};\n\n\n"],"names":["pathPartReg","backslashReg","stringToPath","result","replace","match","number","quote","string","push","parseInt","immutableSplice","arr","start","deleteCount","items","slice","setValue","target","field","value","isArray","isNumber","Error","splice","immutableSet","path","isPlainObject","isString","length","isEmpty","reduce","accu","pathSplit","childTarget","has","tail","immutablePush","newEntries","newEntry","immutablePop","immutableShift","immutableUnshift","reverse","immutableSort","compareFunction","sort","immutableReverse","immutableDelete","index","concat","set","immuSet","immuSplice","immuPush","pop","immuPop","shift","immuShift","unshift","immuUnshift","immuSort","immuReverse","immuDelete"],"mappings":"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"}